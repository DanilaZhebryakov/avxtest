Задача данныой работы - показать прироост производительности при использовании [avx2][wiki_avx], в случаях автоматических оптимизаций комилятора (-O3) и при явном использовании этих инструкций. Во всех случаях использование avx-инструкций разрешено флагом -mavx2 (в противном случае компилятор не может использовать avx) В качестве тестовой задачи взято построение [множества Мандельброта][mandelbrot_set]. Для измерения производительности измерялось время рассчётов (отдельно от вывода на экран). Данные рассчётов записывались в буффер, после чего отдельно выводились на экран для исключения связанных с этим задержек. Время работы графической части так же измерялось (для сравнения) Это время вне зависимости от использованного алгоритма составляло около 1 [мс][wiki_millis] на кадр. (значительно меньше, чем время рассчётов)

 Измеряемое время выводится на экран во время работы программы. Это время практически не меняется для данной точки на масштабе минут, но может различаться для значительно разнесённых во времени измерений. Возмоно имели место внешние факторы (напр. температура процессора, заряд батареи, состояние ОС...), но их влияние минимизировалось за счёт того, что все измерения проводились последовательно друг за другом при одинаковых условиях.

Для алгоритма измерялись 2 значения времени: при начальном положении экрана(default) и при приближении, так что чёрная область занимала весь экран (максимальная сложность рассчётов) (указано как **[default_time]/[max_time] мс на кадр**) Большинство тестов проводилось с флогом -O3. 

### Файл [no-simd.cpp][github_nosimd]
Тривиально реализованный алгоритм. Каждая точка рассчитывается отдельно. Специальных оптимизаций под simd не делается. AVX-инструкции не используются. По ассемблерному выводу видно, что компилятор не использовал simd инструкции для ускорения программы. Время рассчётов: 40/370 мс на кадр

### Файл [array.cpp][github_array]
Элементы разделены на блоки по 256 бит (8 точек), операции производятся над целыми блоками поэлементно. Операции вынесены в отдельные функции, прямо соответствующие avx-инструкциям. В таких условиях компилятор начинает применять оптимизации с использованием avx, но почему-то только в некоторых местах. Есть прирост производительности, но он значительно меньше ожидаемого. Время: 32/250 мс на кадр (на 30% быстрее)

### Файл [array_nofunc.cpp][github_array_nofunc]
 аналогичен array.cpp, но функции работы с числами подставлены прямо в код в местах вызова. По не очень понятным причинам, наблюдается незначительный прирост производительности. Время: 31/240 мс на кадр

### Файл [intrinsic.cpp][github_intrin] 
 явным образом использованы avx-инструкции (через [intrinsic-и][wiki_intrinsic]) при работе с упакованными числами. Структура алгоритма та же, что в файле array.cpp Время: 7/51 мс на кадр.  Прирост производительности более чем в 7 раз по сранению с исходным вариантом. Посмотрев в ассемблерный вывод, можно найти эти инструкции. Компилятор так же сделал некоторое количество оптимизаций (вынос кода), что значительно сократило количество инструкций, и, соответственно, время работы. Ускорение наибольшим образом проявляется на большой сложности вычислений. Это связано с некоторыми потерями времени на подготовку блоков данных.

#### Дополнительный тест с компиляцией без оптимизаций компилятора (-O0)
Время: 90/785 мс на кадр для файла no-simd.cpp и 207/1653 мс на кадр для intrinsic.cpp То есть при отсутствии оптимизаций использование simd ухудшает производительность. Такое уменьшение  обусловлено большим количеством пересылок в/из памяти, что и замедляет алгоритм. Так же компилятор не исправил незначительные огрехи, связанные с повторным вычислением одного и того же результата. Сравним так же производительность файла intrinsic.cpp  на различных флагах оптимизации, чтобы проверить, когда проявляется эффект ускорения Но даже скомпилировав с O1 получаем результат, почти совпадающий с O3: 7/52 мс на кадр. Отсюда можно сделать вывод, что ускорение за счёт  avx инструкций проявляется даже на малых уровнях оптимизации. Ограничивающий фактор - излишние обращения к памяти, а их исключение в данной задаче несложно. Большая оптимизация почти не даёт эффекта.

## Результаты:
| Test            | Default time, ㎳  | Max time, ㎳ | boost (def/max) |
------------------|-------------------|-------------|-------|
| No simd (-O3)   | 40                | 370         |**1 / 1** (base) |
| No simd (-O0)   | 90                | 785         |<font color="orange"> 0.4 / 0.5 </font>  |
| Array           | 32                | 250         |1.25 / 1.5     |
| Array (nofunc)  | 31                | 240         |1.3 / 1.54     |
| Intrinsic (-O3) | 7                 | 51          |<font color="green"> 5.7 / 7.25 </font>    |
| Intrinsic (-O1) | 7                 | 52          |<font color="green"> 5.7 / 7.1  </font>    |
| Intrinsic (-O0) | 207               | 1653        |<font color="red"> 0.2 / 0.2 </font>   |


**Вывод:** Использование SIMD инструкций значительно (более чем в 7 раз(max) и в 5-6 раз(default)  для AVX2 и данной задачи) Компилятор почти не применяяет simd инструкции если это не указано явно. В этом случае требуется оптимизировать код вручную. Тем не менее, базовые оптимизации компилятора обеспечивают эффективную работу с регистрами и памятью, без чего оптимизации simd инструкциями практически бесполезны.

[mandelbrot_set]: https://en.wikipedia.org/wiki/Mandelbrot_set

[wiki_avx]: https://ru.wikipedia.org/wiki/AVX

[wiki_intrinsic]: https://en.wikipedia.org/wiki/Intrinsic_function

[wiki_millis]: https://en.wikipedia.org/wiki/Millisecond

[github_nosimd]: https://github.com/DanilaZhebryakov/avxtest/blob/main/no-simd.cpp

[github_array]: https://github.com/DanilaZhebryakov/avxtest/blob/main/array.cpp

[github_array_nofunc]: https://github.com/DanilaZhebryakov/avxtest/blob/main/array_nofunc.cpp

[github_intrin]: https://github.com/DanilaZhebryakov/avxtest/blob/main/intrinsic.cpp